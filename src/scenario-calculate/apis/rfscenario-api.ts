/* eslint-disable */
/**
 * 方案计算服务
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import { Configuration } from '../configuration'
import { URL } from '../../sdk-helper'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base'
// @ts-ignore
import { DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput } from '../models'
// @ts-ignore
import { DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput } from '../models'
// @ts-ignore
import { DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput } from '../models'
// @ts-ignore
import { DhiDssScenarioComputeScenarioDtosScenarioInfo } from '../models'
/**
 * RFScenarioApi - axios parameter creator
 * @export
 */
export const RFScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 关键词：      流域洪水、自动预报        使用场景：      此接口用于构建流域洪水自动预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，其中初始场默认采用前一次自动计算结果作为热启动文件；其他数据来源优先选择实测数据。完成各类数据的构建之后将其入库保存，以便于后续计算的时候从数据库获取相应的数据并写入模型。      该接口通常由定时任务调度进行调用，用户不需要直接调用该接口，在该接口完成自动预报方案的创建之后，通常将调用ModelDriver计算服务的/ModelRun/RunModel接口来执行该方案的计算。        相关背景：      自动预报，即以一定规则在后台自动执行的预报，不需要人为干预。自动预报的模式有两种，一种是以一定的周期定时滚动执行预报，例如每天执行一次预报，每小时执行一次预报等；另一种是以条件进行触发的预报，例如当降雨达到一定条件的时候触发执行滚动预报，当降雨小于某个阈值的时候再停止执行滚动预报。一般情况下，流域洪水预报可以采用第一种，并在汛期和非汛期采用不同的滚动周期。    输出：      如果创建成功，将返回所创建自动预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
     * @summary 创建流域洪水自动预报的方案
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodAutoForecastCreatePost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/scenario-compute/river-flood/auto-forecast/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      流域洪水、行蓄洪区、调度    使用场景：      此接口用于创建行蓄洪区调度方案，行蓄洪区调度方案往往是和流域洪水调度方案相关联的，如果用户在流域洪水调度方案中开启了部分行蓄洪区泄洪闸，或者退洪闸进行泄洪，这个泄洪的过程可以利用行蓄洪区调度方案进行模拟。      除了创建方案之外，接口也会接入行蓄洪区的初始水位数据（来自输入），泄洪闸/退洪闸的过闸流量数据（来自流域洪水调度方案的流量结果）,完成这些数据的构建之后将其入库保存，用户通常无需做进一步的修改。      完成方案创建之后，可以调用ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      流域洪水调度方案是针对河道的调度模拟，假如河道上的控制水位达到了部分行蓄洪区的启用水位，那么调度的措施中可能包含开启这部分行蓄洪区泄洪闸，或者退洪闸进行泄洪。行蓄洪区调度方案用来对这部分行蓄洪区中洪水演进过程的模拟，每一个行蓄洪区由于其地理位置各不相同，因此都会有一个对应的模板方案，启用的是哪个行蓄洪区，就采用其对应的模板方案来创建调度方案。    输入：      输入主要包括流域洪水调度方案ID、行蓄洪区ID、方案的名称、描述、初始水位等。方案的开始时间和结束时间，不需要输入，会自动和流域洪水调度方案的时间保持一致。    输出：      如果创建成功，将返回所创建行蓄洪区调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
     * @summary 创建行蓄洪区调度的方案
     * @param {DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput} [dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodFloodStorageAreaCreatePost: async (
      dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput?: DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/scenario-compute/river-flood/flood-storage-area/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      流域洪水、人工预报    使用场景：      此接口用于创建流域洪水人工预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      人工预报，即当自动预报无法满足用户的需求时，比如自动预报所接入的数据有缺失，或者有问题时，用户需要进行人为干预。用户可以通过创建人工预报方案，手动更新模型所需的相关数据，来执行预报。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、预报时刻等。    输出：      如果创建成功，将返回所创建人工预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
     * @summary 创建流域洪水人工预报的方案
     * @param {DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput} [dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodManualForecastCreatePost: async (
      dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput?: DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/scenario-compute/river-flood/manual-forecast/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      流域洪水、调度    使用场景：      此接口用于创建流域洪水调度方案，一般可以基于某一个特定的流域洪水调度模板方案来创建。除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      调度方案，当用户需要针对某一种洪水情景进行防汛调度模拟时，可以创建调度方案。基于以往的经验，或者基于相关国家规定，可以提前制定好一系列调度方案的模板，用户在创建调度方案时，可以自行选择需要采用的调度模板。创建调度方案之后，用户可以进一步修改其泵、闸等结构物的调度数据，以辅助判断有效的调度措施。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、模板方案ID等。    输出：      如果创建成功，将返回所创建调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
     * @summary 创建流域洪水调度的方案
     * @param {DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput} [dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodScheduleCreatePost: async (
      dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput?: DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/scenario-compute/river-flood/schedule/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RFScenarioApi - functional programming interface
 * @export
 */
export const RFScenarioApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RFScenarioApiAxiosParamCreator(configuration)
  return {
    /**
     * 关键词：      流域洪水、自动预报        使用场景：      此接口用于构建流域洪水自动预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，其中初始场默认采用前一次自动计算结果作为热启动文件；其他数据来源优先选择实测数据。完成各类数据的构建之后将其入库保存，以便于后续计算的时候从数据库获取相应的数据并写入模型。      该接口通常由定时任务调度进行调用，用户不需要直接调用该接口，在该接口完成自动预报方案的创建之后，通常将调用ModelDriver计算服务的/ModelRun/RunModel接口来执行该方案的计算。        相关背景：      自动预报，即以一定规则在后台自动执行的预报，不需要人为干预。自动预报的模式有两种，一种是以一定的周期定时滚动执行预报，例如每天执行一次预报，每小时执行一次预报等；另一种是以条件进行触发的预报，例如当降雨达到一定条件的时候触发执行滚动预报，当降雨小于某个阈值的时候再停止执行滚动预报。一般情况下，流域洪水预报可以采用第一种，并在汛期和非汛期采用不同的滚动周期。    输出：      如果创建成功，将返回所创建自动预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
     * @summary 创建流域洪水自动预报的方案
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1ScenarioComputeRiverFloodAutoForecastCreatePost(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1ScenarioComputeRiverFloodAutoForecastCreatePost(
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      流域洪水、行蓄洪区、调度    使用场景：      此接口用于创建行蓄洪区调度方案，行蓄洪区调度方案往往是和流域洪水调度方案相关联的，如果用户在流域洪水调度方案中开启了部分行蓄洪区泄洪闸，或者退洪闸进行泄洪，这个泄洪的过程可以利用行蓄洪区调度方案进行模拟。      除了创建方案之外，接口也会接入行蓄洪区的初始水位数据（来自输入），泄洪闸/退洪闸的过闸流量数据（来自流域洪水调度方案的流量结果）,完成这些数据的构建之后将其入库保存，用户通常无需做进一步的修改。      完成方案创建之后，可以调用ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      流域洪水调度方案是针对河道的调度模拟，假如河道上的控制水位达到了部分行蓄洪区的启用水位，那么调度的措施中可能包含开启这部分行蓄洪区泄洪闸，或者退洪闸进行泄洪。行蓄洪区调度方案用来对这部分行蓄洪区中洪水演进过程的模拟，每一个行蓄洪区由于其地理位置各不相同，因此都会有一个对应的模板方案，启用的是哪个行蓄洪区，就采用其对应的模板方案来创建调度方案。    输入：      输入主要包括流域洪水调度方案ID、行蓄洪区ID、方案的名称、描述、初始水位等。方案的开始时间和结束时间，不需要输入，会自动和流域洪水调度方案的时间保持一致。    输出：      如果创建成功，将返回所创建行蓄洪区调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
     * @summary 创建行蓄洪区调度的方案
     * @param {DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput} [dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1ScenarioComputeRiverFloodFloodStorageAreaCreatePost(
      dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput?: DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1ScenarioComputeRiverFloodFloodStorageAreaCreatePost(
          dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      流域洪水、人工预报    使用场景：      此接口用于创建流域洪水人工预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      人工预报，即当自动预报无法满足用户的需求时，比如自动预报所接入的数据有缺失，或者有问题时，用户需要进行人为干预。用户可以通过创建人工预报方案，手动更新模型所需的相关数据，来执行预报。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、预报时刻等。    输出：      如果创建成功，将返回所创建人工预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
     * @summary 创建流域洪水人工预报的方案
     * @param {DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput} [dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1ScenarioComputeRiverFloodManualForecastCreatePost(
      dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput?: DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1ScenarioComputeRiverFloodManualForecastCreatePost(
          dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      流域洪水、调度    使用场景：      此接口用于创建流域洪水调度方案，一般可以基于某一个特定的流域洪水调度模板方案来创建。除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      调度方案，当用户需要针对某一种洪水情景进行防汛调度模拟时，可以创建调度方案。基于以往的经验，或者基于相关国家规定，可以提前制定好一系列调度方案的模板，用户在创建调度方案时，可以自行选择需要采用的调度模板。创建调度方案之后，用户可以进一步修改其泵、闸等结构物的调度数据，以辅助判断有效的调度措施。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、模板方案ID等。    输出：      如果创建成功，将返回所创建调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
     * @summary 创建流域洪水调度的方案
     * @param {DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput} [dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1ScenarioComputeRiverFloodScheduleCreatePost(
      dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput?: DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1ScenarioComputeRiverFloodScheduleCreatePost(
          dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * RFScenarioApi - factory interface
 * @export
 */
export const RFScenarioApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RFScenarioApiFp(configuration)
  return {
    /**
     * 关键词：      流域洪水、自动预报        使用场景：      此接口用于构建流域洪水自动预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，其中初始场默认采用前一次自动计算结果作为热启动文件；其他数据来源优先选择实测数据。完成各类数据的构建之后将其入库保存，以便于后续计算的时候从数据库获取相应的数据并写入模型。      该接口通常由定时任务调度进行调用，用户不需要直接调用该接口，在该接口完成自动预报方案的创建之后，通常将调用ModelDriver计算服务的/ModelRun/RunModel接口来执行该方案的计算。        相关背景：      自动预报，即以一定规则在后台自动执行的预报，不需要人为干预。自动预报的模式有两种，一种是以一定的周期定时滚动执行预报，例如每天执行一次预报，每小时执行一次预报等；另一种是以条件进行触发的预报，例如当降雨达到一定条件的时候触发执行滚动预报，当降雨小于某个阈值的时候再停止执行滚动预报。一般情况下，流域洪水预报可以采用第一种，并在汛期和非汛期采用不同的滚动周期。    输出：      如果创建成功，将返回所创建自动预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
     * @summary 创建流域洪水自动预报的方案
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodAutoForecastCreatePost(
      options?: any,
    ): AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo> {
      return localVarFp
        .apiV1ScenarioComputeRiverFloodAutoForecastCreatePost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      流域洪水、行蓄洪区、调度    使用场景：      此接口用于创建行蓄洪区调度方案，行蓄洪区调度方案往往是和流域洪水调度方案相关联的，如果用户在流域洪水调度方案中开启了部分行蓄洪区泄洪闸，或者退洪闸进行泄洪，这个泄洪的过程可以利用行蓄洪区调度方案进行模拟。      除了创建方案之外，接口也会接入行蓄洪区的初始水位数据（来自输入），泄洪闸/退洪闸的过闸流量数据（来自流域洪水调度方案的流量结果）,完成这些数据的构建之后将其入库保存，用户通常无需做进一步的修改。      完成方案创建之后，可以调用ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      流域洪水调度方案是针对河道的调度模拟，假如河道上的控制水位达到了部分行蓄洪区的启用水位，那么调度的措施中可能包含开启这部分行蓄洪区泄洪闸，或者退洪闸进行泄洪。行蓄洪区调度方案用来对这部分行蓄洪区中洪水演进过程的模拟，每一个行蓄洪区由于其地理位置各不相同，因此都会有一个对应的模板方案，启用的是哪个行蓄洪区，就采用其对应的模板方案来创建调度方案。    输入：      输入主要包括流域洪水调度方案ID、行蓄洪区ID、方案的名称、描述、初始水位等。方案的开始时间和结束时间，不需要输入，会自动和流域洪水调度方案的时间保持一致。    输出：      如果创建成功，将返回所创建行蓄洪区调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
     * @summary 创建行蓄洪区调度的方案
     * @param {DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput} [dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodFloodStorageAreaCreatePost(
      dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput?: DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
      options?: any,
    ): AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo> {
      return localVarFp
        .apiV1ScenarioComputeRiverFloodFloodStorageAreaCreatePost(
          dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      流域洪水、人工预报    使用场景：      此接口用于创建流域洪水人工预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      人工预报，即当自动预报无法满足用户的需求时，比如自动预报所接入的数据有缺失，或者有问题时，用户需要进行人为干预。用户可以通过创建人工预报方案，手动更新模型所需的相关数据，来执行预报。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、预报时刻等。    输出：      如果创建成功，将返回所创建人工预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
     * @summary 创建流域洪水人工预报的方案
     * @param {DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput} [dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodManualForecastCreatePost(
      dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput?: DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
      options?: any,
    ): AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo> {
      return localVarFp
        .apiV1ScenarioComputeRiverFloodManualForecastCreatePost(
          dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      流域洪水、调度    使用场景：      此接口用于创建流域洪水调度方案，一般可以基于某一个特定的流域洪水调度模板方案来创建。除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      调度方案，当用户需要针对某一种洪水情景进行防汛调度模拟时，可以创建调度方案。基于以往的经验，或者基于相关国家规定，可以提前制定好一系列调度方案的模板，用户在创建调度方案时，可以自行选择需要采用的调度模板。创建调度方案之后，用户可以进一步修改其泵、闸等结构物的调度数据，以辅助判断有效的调度措施。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、模板方案ID等。    输出：      如果创建成功，将返回所创建调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
     * @summary 创建流域洪水调度的方案
     * @param {DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput} [dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1ScenarioComputeRiverFloodScheduleCreatePost(
      dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput?: DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
      options?: any,
    ): AxiosPromise<DhiDssScenarioComputeScenarioDtosScenarioInfo> {
      return localVarFp
        .apiV1ScenarioComputeRiverFloodScheduleCreatePost(
          dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RFScenarioApi - object-oriented interface
 * @export
 * @class RFScenarioApi
 * @extends {BaseAPI}
 */
export class RFScenarioApi extends BaseAPI {
  /**
   * 关键词：      流域洪水、自动预报        使用场景：      此接口用于构建流域洪水自动预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，其中初始场默认采用前一次自动计算结果作为热启动文件；其他数据来源优先选择实测数据。完成各类数据的构建之后将其入库保存，以便于后续计算的时候从数据库获取相应的数据并写入模型。      该接口通常由定时任务调度进行调用，用户不需要直接调用该接口，在该接口完成自动预报方案的创建之后，通常将调用ModelDriver计算服务的/ModelRun/RunModel接口来执行该方案的计算。        相关背景：      自动预报，即以一定规则在后台自动执行的预报，不需要人为干预。自动预报的模式有两种，一种是以一定的周期定时滚动执行预报，例如每天执行一次预报，每小时执行一次预报等；另一种是以条件进行触发的预报，例如当降雨达到一定条件的时候触发执行滚动预报，当降雨小于某个阈值的时候再停止执行滚动预报。一般情况下，流域洪水预报可以采用第一种，并在汛期和非汛期采用不同的滚动周期。    输出：      如果创建成功，将返回所创建自动预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
   * @summary 创建流域洪水自动预报的方案
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RFScenarioApi
   */
  public apiV1ScenarioComputeRiverFloodAutoForecastCreatePost(options?: AxiosRequestConfig) {
    return RFScenarioApiFp(this.configuration)
      .apiV1ScenarioComputeRiverFloodAutoForecastCreatePost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      流域洪水、行蓄洪区、调度    使用场景：      此接口用于创建行蓄洪区调度方案，行蓄洪区调度方案往往是和流域洪水调度方案相关联的，如果用户在流域洪水调度方案中开启了部分行蓄洪区泄洪闸，或者退洪闸进行泄洪，这个泄洪的过程可以利用行蓄洪区调度方案进行模拟。      除了创建方案之外，接口也会接入行蓄洪区的初始水位数据（来自输入），泄洪闸/退洪闸的过闸流量数据（来自流域洪水调度方案的流量结果）,完成这些数据的构建之后将其入库保存，用户通常无需做进一步的修改。      完成方案创建之后，可以调用ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      流域洪水调度方案是针对河道的调度模拟，假如河道上的控制水位达到了部分行蓄洪区的启用水位，那么调度的措施中可能包含开启这部分行蓄洪区泄洪闸，或者退洪闸进行泄洪。行蓄洪区调度方案用来对这部分行蓄洪区中洪水演进过程的模拟，每一个行蓄洪区由于其地理位置各不相同，因此都会有一个对应的模板方案，启用的是哪个行蓄洪区，就采用其对应的模板方案来创建调度方案。    输入：      输入主要包括流域洪水调度方案ID、行蓄洪区ID、方案的名称、描述、初始水位等。方案的开始时间和结束时间，不需要输入，会自动和流域洪水调度方案的时间保持一致。    输出：      如果创建成功，将返回所创建行蓄洪区调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
   * @summary 创建行蓄洪区调度的方案
   * @param {DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput} [dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RFScenarioApi
   */
  public apiV1ScenarioComputeRiverFloodFloodStorageAreaCreatePost(
    dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput?: DhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
    options?: AxiosRequestConfig,
  ) {
    return RFScenarioApiFp(this.configuration)
      .apiV1ScenarioComputeRiverFloodFloodStorageAreaCreatePost(
        dhiDssScenarioComputeRfDtosCreateFloodStorageAreaScenarioInput,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      流域洪水、人工预报    使用场景：      此接口用于创建流域洪水人工预报方案，除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      人工预报，即当自动预报无法满足用户的需求时，比如自动预报所接入的数据有缺失，或者有问题时，用户需要进行人为干预。用户可以通过创建人工预报方案，手动更新模型所需的相关数据，来执行预报。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、预报时刻等。    输出：      如果创建成功，将返回所创建人工预报方案的具体信息，包括方案ID，方案名称、开始时间、结束时间、预报时刻等。
   * @summary 创建流域洪水人工预报的方案
   * @param {DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput} [dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RFScenarioApi
   */
  public apiV1ScenarioComputeRiverFloodManualForecastCreatePost(
    dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput?: DhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
    options?: AxiosRequestConfig,
  ) {
    return RFScenarioApiFp(this.configuration)
      .apiV1ScenarioComputeRiverFloodManualForecastCreatePost(
        dhiDssScenarioComputeScenarioDtosCreateManualScenarioInput,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      流域洪水、调度    使用场景：      此接口用于创建流域洪水调度方案，一般可以基于某一个特定的流域洪水调度模板方案来创建。除了创建方案之外，也会准备模型计算所需要的初始场数据、边界数据、实时校正数据等，数据来源优先选择实测数据，完成各类数据的构建之后将其入库保存。      在完成该方案的创建之后，用户往往还需要通过系统界面对默认设置的初始场数据、边界数据、实时校正数据等进行编辑和修正，并更新到数据库中，以便于后续计算的时候从数据库获取相应的数据并写入模型。相关接口如下：      模型信息服务的/api/v1/model-information/initial-data/save接口用于设置初始场数据；      模型信息服务的/api/v1/model-information/ad-conditon/save接口用于设置实时校正数据；      模型信息服务的/api/v1/model-information/boundary/timeseries/update接口用于设置边界数据；      ModelDriver计算服务的/ModelRun/RunModel接口用于执行方案的计算。    相关背景：      调度方案，当用户需要针对某一种洪水情景进行防汛调度模拟时，可以创建调度方案。基于以往的经验，或者基于相关国家规定，可以提前制定好一系列调度方案的模板，用户在创建调度方案时，可以自行选择需要采用的调度模板。创建调度方案之后，用户可以进一步修改其泵、闸等结构物的调度数据，以辅助判断有效的调度措施。    输入：      输入主要包括方案的名称、描述、开始时间、结束时间、模板方案ID等。    输出：      如果创建成功，将返回所创建调度方案的具体信息，包括方案ID，方案名称、开始时间、结束时间等。
   * @summary 创建流域洪水调度的方案
   * @param {DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput} [dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RFScenarioApi
   */
  public apiV1ScenarioComputeRiverFloodScheduleCreatePost(
    dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput?: DhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
    options?: AxiosRequestConfig,
  ) {
    return RFScenarioApiFp(this.configuration)
      .apiV1ScenarioComputeRiverFloodScheduleCreatePost(
        dhiDssScenarioComputeRfDtosCreateScheduleScenarioInput,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
