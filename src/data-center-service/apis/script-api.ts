/* eslint-disable */
/**
 * 数据中台服务
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import { Configuration } from '../configuration'
import { URL } from '../../sdk-helper'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base'
// @ts-ignore
import { AddAlgorithmInstanceInput } from '../models'
// @ts-ignore
import { AddAlgorithmSidecarInput } from '../models'
// @ts-ignore
import { DeleteAlgorithmInstanceInput } from '../models'
// @ts-ignore
import { DeleteAlgorithmSidecarInput } from '../models'
// @ts-ignore
import { DeleteInstanceListInput } from '../models'
// @ts-ignore
import { DeployMachineOutput } from '../models'
// @ts-ignore
import { QueryAlgorithmByCodeOutput } from '../models'
// @ts-ignore
import { QueryAlgorithmByCodeOutputPage } from '../models'
// @ts-ignore
import { QueryAlgorithmByConInput } from '../models'
/**
 * ScriptApi - axios parameter creator
 * @export
 */
export const ScriptApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1AddAlgorithmInstancePost: async (
      addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/add/algorithm-instance`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addAlgorithmInstanceInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1AddAlgorithmInstancePost_1: async (
      addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/add/algorithm-instance`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addAlgorithmInstanceInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 根据Python脚本唯一编码删除Python脚本实例
     * @param {DeleteInstanceListInput} [deleteInstanceListInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstanceListPost: async (
      deleteInstanceListInput?: DeleteInstanceListInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/delete/algorithm-instance-list`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteInstanceListInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 根据Python脚本唯一编码删除Python脚本实例
     * @param {DeleteInstanceListInput} [deleteInstanceListInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstanceListPost_2: async (
      deleteInstanceListInput?: DeleteInstanceListInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/delete/algorithm-instance-list`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteInstanceListInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 批量删除Python算法脚本实例
     * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstancePost: async (
      deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/delete/algorithm-instance`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteAlgorithmInstanceInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 批量删除Python算法脚本实例
     * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstancePost_3: async (
      deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/delete/algorithm-instance`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteAlgorithmInstanceInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 删除Python算法脚本
     * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmPost: async (
      deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/delete/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteAlgorithmSidecarInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 删除Python算法脚本
     * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmPost_4: async (
      deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/delete/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteAlgorithmSidecarInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 停用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DisableAlgorithmGet: async (
      algorithmInstanceCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/disable/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmInstanceCode !== undefined) {
        localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 停用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DisableAlgorithmGet_5: async (
      algorithmInstanceCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/disable/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmInstanceCode !== undefined) {
        localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 启用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1EnableAlgorithmGet: async (
      algorithmInstanceCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enable/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmInstanceCode !== undefined) {
        localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 启用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1EnableAlgorithmGet_6: async (
      algorithmInstanceCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enable/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmInstanceCode !== undefined) {
        localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法脚本实例的运行日志
     * @param {string} [algorithmInstanceCode]
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmLogGet: async (
      algorithmInstanceCode?: string,
      startTime?: string,
      endTime?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/get/algorithm/log`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmInstanceCode !== undefined) {
        localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] =
          (startTime as any) instanceof Date ? (startTime as any).toISOString() : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] =
          (endTime as any) instanceof Date ? (endTime as any).toISOString() : endTime
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法脚本实例的运行日志
     * @param {string} [algorithmInstanceCode]
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmLogGet_7: async (
      algorithmInstanceCode?: string,
      startTime?: string,
      endTime?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/get/algorithm/log`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmInstanceCode !== undefined) {
        localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode
      }

      if (startTime !== undefined) {
        localVarQueryParameter['startTime'] =
          (startTime as any) instanceof Date ? (startTime as any).toISOString() : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['endTime'] =
          (endTime as any) instanceof Date ? (endTime as any).toISOString() : endTime
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法目标部署机器可分配的端口资源
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmTargetDeployMachineGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/get/algorithm/target/deploy/machine`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法目标部署机器可分配的端口资源
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmTargetDeployMachineGet_8: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/get/algorithm/target/deploy/machine`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
     * @summary 获取可用的python镜像版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAvaliablePythonVersionGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/get-avaliable-python-version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
     * @summary 获取可用的python镜像版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAvaliablePythonVersionGet_9: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/get-avaliable-python-version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 通过算法唯一编码查询算法详细信息
     * @param {string} [algorithmCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmByCodeGet: async (
      algorithmCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/query/algorithm/by/code`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmCode !== undefined) {
        localVarQueryParameter['algorithmCode'] = algorithmCode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 通过算法唯一编码查询算法详细信息
     * @param {string} [algorithmCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmByCodeGet_10: async (
      algorithmCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/query/algorithm/by/code`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmCode !== undefined) {
        localVarQueryParameter['algorithmCode'] = algorithmCode
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 分页查询算法及算法实例信息
     * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmListByConPost: async (
      queryAlgorithmByConInput?: QueryAlgorithmByConInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/query/algorithm/list/by/con`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryAlgorithmByConInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 分页查询算法及算法实例信息
     * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmListByConPost_11: async (
      queryAlgorithmByConInput?: QueryAlgorithmByConInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/query/algorithm/list/by/con`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryAlgorithmByConInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
     * @summary 运行Python算法脚本实例
     * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RunAlgorithmPost: async (
      algorithmCode?: string,
      requestBody?: { [key: string]: string },
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/run/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmCode !== undefined) {
        localVarQueryParameter['algorithmCode'] = algorithmCode
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
     * @summary 运行Python算法脚本实例
     * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RunAlgorithmPost_12: async (
      algorithmCode?: string,
      requestBody?: { [key: string]: string },
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/run/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (algorithmCode !== undefined) {
        localVarQueryParameter['algorithmCode'] = algorithmCode
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1SaveAlgorithmPost: async (
      addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/save/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addAlgorithmSidecarInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1SaveAlgorithmPost_13: async (
      addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/save/algorithm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addAlgorithmSidecarInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ScriptApi - functional programming interface
 * @export
 */
export const ScriptApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScriptApiAxiosParamCreator(configuration)
  return {
    /**
     * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1AddAlgorithmInstancePost(
      addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AddAlgorithmInstancePost(
        addAlgorithmInstanceInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1AddAlgorithmInstancePost_1(
      addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AddAlgorithmInstancePost_1(
        addAlgorithmInstanceInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 根据Python脚本唯一编码删除Python脚本实例
     * @param {DeleteInstanceListInput} [deleteInstanceListInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DeleteAlgorithmInstanceListPost(
      deleteInstanceListInput?: DeleteInstanceListInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1DeleteAlgorithmInstanceListPost(
          deleteInstanceListInput,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 根据Python脚本唯一编码删除Python脚本实例
     * @param {DeleteInstanceListInput} [deleteInstanceListInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DeleteAlgorithmInstanceListPost_2(
      deleteInstanceListInput?: DeleteInstanceListInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1DeleteAlgorithmInstanceListPost_2(
          deleteInstanceListInput,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 批量删除Python算法脚本实例
     * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DeleteAlgorithmInstancePost(
      deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DeleteAlgorithmInstancePost(
        deleteAlgorithmInstanceInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 批量删除Python算法脚本实例
     * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DeleteAlgorithmInstancePost_3(
      deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DeleteAlgorithmInstancePost_3(
        deleteAlgorithmInstanceInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 删除Python算法脚本
     * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DeleteAlgorithmPost(
      deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DeleteAlgorithmPost(
        deleteAlgorithmSidecarInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 删除Python算法脚本
     * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DeleteAlgorithmPost_4(
      deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DeleteAlgorithmPost_4(
        deleteAlgorithmSidecarInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 停用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DisableAlgorithmGet(
      algorithmInstanceCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DisableAlgorithmGet(
        algorithmInstanceCode,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 停用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1DisableAlgorithmGet_5(
      algorithmInstanceCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DisableAlgorithmGet_5(
        algorithmInstanceCode,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 启用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1EnableAlgorithmGet(
      algorithmInstanceCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1EnableAlgorithmGet(
        algorithmInstanceCode,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 启用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1EnableAlgorithmGet_6(
      algorithmInstanceCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1EnableAlgorithmGet_6(
        algorithmInstanceCode,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法脚本实例的运行日志
     * @param {string} [algorithmInstanceCode]
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1GetAlgorithmLogGet(
      algorithmInstanceCode?: string,
      startTime?: string,
      endTime?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1GetAlgorithmLogGet(
        algorithmInstanceCode,
        startTime,
        endTime,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法脚本实例的运行日志
     * @param {string} [algorithmInstanceCode]
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1GetAlgorithmLogGet_7(
      algorithmInstanceCode?: string,
      startTime?: string,
      endTime?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1GetAlgorithmLogGet_7(
        algorithmInstanceCode,
        startTime,
        endTime,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法目标部署机器可分配的端口资源
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1GetAlgorithmTargetDeployMachineGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployMachineOutput>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1GetAlgorithmTargetDeployMachineGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法目标部署机器可分配的端口资源
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1GetAlgorithmTargetDeployMachineGet_8(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployMachineOutput>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1GetAlgorithmTargetDeployMachineGet_8(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
     * @summary 获取可用的python镜像版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1GetAvaliablePythonVersionGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1GetAvaliablePythonVersionGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
     * @summary 获取可用的python镜像版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1GetAvaliablePythonVersionGet_9(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiV1GetAvaliablePythonVersionGet_9(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 通过算法唯一编码查询算法详细信息
     * @param {string} [algorithmCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1QueryAlgorithmByCodeGet(
      algorithmCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1QueryAlgorithmByCodeGet(
        algorithmCode,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 通过算法唯一编码查询算法详细信息
     * @param {string} [algorithmCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1QueryAlgorithmByCodeGet_10(
      algorithmCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1QueryAlgorithmByCodeGet_10(
        algorithmCode,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 分页查询算法及算法实例信息
     * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1QueryAlgorithmListByConPost(
      queryAlgorithmByConInput?: QueryAlgorithmByConInput,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutputPage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1QueryAlgorithmListByConPost(
        queryAlgorithmByConInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 分页查询算法及算法实例信息
     * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1QueryAlgorithmListByConPost_11(
      queryAlgorithmByConInput?: QueryAlgorithmByConInput,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutputPage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1QueryAlgorithmListByConPost_11(
        queryAlgorithmByConInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
     * @summary 运行Python算法脚本实例
     * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RunAlgorithmPost(
      algorithmCode?: string,
      requestBody?: { [key: string]: string },
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RunAlgorithmPost(
        algorithmCode,
        requestBody,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
     * @summary 运行Python算法脚本实例
     * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RunAlgorithmPost_12(
      algorithmCode?: string,
      requestBody?: { [key: string]: string },
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RunAlgorithmPost_12(
        algorithmCode,
        requestBody,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1SaveAlgorithmPost(
      addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SaveAlgorithmPost(
        addAlgorithmSidecarInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1SaveAlgorithmPost_13(
      addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SaveAlgorithmPost_13(
        addAlgorithmSidecarInput,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ScriptApi - factory interface
 * @export
 */
export const ScriptApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ScriptApiFp(configuration)
  return {
    /**
     * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1AddAlgorithmInstancePost(
      addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1AddAlgorithmInstancePost_1(
      addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1AddAlgorithmInstancePost_1(addAlgorithmInstanceInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 根据Python脚本唯一编码删除Python脚本实例
     * @param {DeleteInstanceListInput} [deleteInstanceListInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstanceListPost(
      deleteInstanceListInput?: DeleteInstanceListInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 根据Python脚本唯一编码删除Python脚本实例
     * @param {DeleteInstanceListInput} [deleteInstanceListInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstanceListPost_2(
      deleteInstanceListInput?: DeleteInstanceListInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1DeleteAlgorithmInstanceListPost_2(deleteInstanceListInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 批量删除Python算法脚本实例
     * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstancePost(
      deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 批量删除Python算法脚本实例
     * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmInstancePost_3(
      deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1DeleteAlgorithmInstancePost_3(deleteAlgorithmInstanceInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 删除Python算法脚本
     * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmPost(
      deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 删除Python算法脚本
     * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DeleteAlgorithmPost_4(
      deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .apiV1DeleteAlgorithmPost_4(deleteAlgorithmSidecarInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 停用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DisableAlgorithmGet(algorithmInstanceCode?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiV1DisableAlgorithmGet(algorithmInstanceCode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 停用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1DisableAlgorithmGet_5(algorithmInstanceCode?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiV1DisableAlgorithmGet_5(algorithmInstanceCode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 启用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1EnableAlgorithmGet(algorithmInstanceCode?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiV1EnableAlgorithmGet(algorithmInstanceCode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 启用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1EnableAlgorithmGet_6(algorithmInstanceCode?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiV1EnableAlgorithmGet_6(algorithmInstanceCode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法脚本实例的运行日志
     * @param {string} [algorithmInstanceCode]
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmLogGet(
      algorithmInstanceCode?: string,
      startTime?: string,
      endTime?: string,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .apiV1GetAlgorithmLogGet(algorithmInstanceCode, startTime, endTime, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法脚本实例的运行日志
     * @param {string} [algorithmInstanceCode]
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmLogGet_7(
      algorithmInstanceCode?: string,
      startTime?: string,
      endTime?: string,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .apiV1GetAlgorithmLogGet_7(algorithmInstanceCode, startTime, endTime, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法目标部署机器可分配的端口资源
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmTargetDeployMachineGet(options?: any): AxiosPromise<DeployMachineOutput> {
      return localVarFp
        .apiV1GetAlgorithmTargetDeployMachineGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法目标部署机器可分配的端口资源
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAlgorithmTargetDeployMachineGet_8(options?: any): AxiosPromise<DeployMachineOutput> {
      return localVarFp
        .apiV1GetAlgorithmTargetDeployMachineGet_8(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
     * @summary 获取可用的python镜像版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAvaliablePythonVersionGet(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .apiV1GetAvaliablePythonVersionGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
     * @summary 获取可用的python镜像版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1GetAvaliablePythonVersionGet_9(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .apiV1GetAvaliablePythonVersionGet_9(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 通过算法唯一编码查询算法详细信息
     * @param {string} [algorithmCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmByCodeGet(
      algorithmCode?: string,
      options?: any,
    ): AxiosPromise<QueryAlgorithmByCodeOutput> {
      return localVarFp
        .apiV1QueryAlgorithmByCodeGet(algorithmCode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 通过算法唯一编码查询算法详细信息
     * @param {string} [algorithmCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmByCodeGet_10(
      algorithmCode?: string,
      options?: any,
    ): AxiosPromise<QueryAlgorithmByCodeOutput> {
      return localVarFp
        .apiV1QueryAlgorithmByCodeGet_10(algorithmCode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 分页查询算法及算法实例信息
     * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmListByConPost(
      queryAlgorithmByConInput?: QueryAlgorithmByConInput,
      options?: any,
    ): AxiosPromise<QueryAlgorithmByCodeOutputPage> {
      return localVarFp
        .apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 分页查询算法及算法实例信息
     * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1QueryAlgorithmListByConPost_11(
      queryAlgorithmByConInput?: QueryAlgorithmByConInput,
      options?: any,
    ): AxiosPromise<QueryAlgorithmByCodeOutputPage> {
      return localVarFp
        .apiV1QueryAlgorithmListByConPost_11(queryAlgorithmByConInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
     * @summary 运行Python算法脚本实例
     * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RunAlgorithmPost(
      algorithmCode?: string,
      requestBody?: { [key: string]: string },
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .apiV1RunAlgorithmPost(algorithmCode, requestBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
     * @summary 运行Python算法脚本实例
     * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RunAlgorithmPost_12(
      algorithmCode?: string,
      requestBody?: { [key: string]: string },
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .apiV1RunAlgorithmPost_12(algorithmCode, requestBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1SaveAlgorithmPost(
      addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
      options?: any,
    ): AxiosPromise<QueryAlgorithmByCodeOutput> {
      return localVarFp
        .apiV1SaveAlgorithmPost(addAlgorithmSidecarInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1SaveAlgorithmPost_13(
      addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
      options?: any,
    ): AxiosPromise<QueryAlgorithmByCodeOutput> {
      return localVarFp
        .apiV1SaveAlgorithmPost_13(addAlgorithmSidecarInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ScriptApi - object-oriented interface
 * @export
 * @class ScriptApi
 * @extends {BaseAPI}
 */
export class ScriptApi extends BaseAPI {
  /**
   * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 保存Python算法脚本
   * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1AddAlgorithmInstancePost(
    addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 保存Python算法脚本
   * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1AddAlgorithmInstancePost_1(
    addAlgorithmInstanceInput?: AddAlgorithmInstanceInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1AddAlgorithmInstancePost_1(addAlgorithmInstanceInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 根据Python脚本唯一编码删除Python脚本实例
   * @param {DeleteInstanceListInput} [deleteInstanceListInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DeleteAlgorithmInstanceListPost(
    deleteInstanceListInput?: DeleteInstanceListInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 根据Python脚本唯一编码删除Python脚本实例
   * @param {DeleteInstanceListInput} [deleteInstanceListInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DeleteAlgorithmInstanceListPost_2(
    deleteInstanceListInput?: DeleteInstanceListInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1DeleteAlgorithmInstanceListPost_2(deleteInstanceListInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 批量删除Python算法脚本实例
   * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DeleteAlgorithmInstancePost(
    deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 批量删除Python算法脚本实例
   * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DeleteAlgorithmInstancePost_3(
    deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1DeleteAlgorithmInstancePost_3(deleteAlgorithmInstanceInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 删除Python算法脚本
   * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DeleteAlgorithmPost(
    deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 删除Python算法脚本
   * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DeleteAlgorithmPost_4(
    deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1DeleteAlgorithmPost_4(deleteAlgorithmSidecarInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 停用算法脚本实例
   * @param {string} [algorithmInstanceCode] 算法实例唯一编码
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DisableAlgorithmGet(algorithmInstanceCode?: string, options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1DisableAlgorithmGet(algorithmInstanceCode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 停用算法脚本实例
   * @param {string} [algorithmInstanceCode] 算法实例唯一编码
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1DisableAlgorithmGet_5(algorithmInstanceCode?: string, options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1DisableAlgorithmGet_5(algorithmInstanceCode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 启用算法脚本实例
   * @param {string} [algorithmInstanceCode] 算法实例唯一编码
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1EnableAlgorithmGet(algorithmInstanceCode?: string, options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1EnableAlgorithmGet(algorithmInstanceCode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 启用算法脚本实例
   * @param {string} [algorithmInstanceCode] 算法实例唯一编码
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1EnableAlgorithmGet_6(algorithmInstanceCode?: string, options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1EnableAlgorithmGet_6(algorithmInstanceCode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 获取算法脚本实例的运行日志
   * @param {string} [algorithmInstanceCode]
   * @param {string} [startTime]
   * @param {string} [endTime]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1GetAlgorithmLogGet(
    algorithmInstanceCode?: string,
    startTime?: string,
    endTime?: string,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1GetAlgorithmLogGet(algorithmInstanceCode, startTime, endTime, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 获取算法脚本实例的运行日志
   * @param {string} [algorithmInstanceCode]
   * @param {string} [startTime]
   * @param {string} [endTime]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1GetAlgorithmLogGet_7(
    algorithmInstanceCode?: string,
    startTime?: string,
    endTime?: string,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1GetAlgorithmLogGet_7(algorithmInstanceCode, startTime, endTime, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 获取算法目标部署机器可分配的端口资源
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1GetAlgorithmTargetDeployMachineGet(options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1GetAlgorithmTargetDeployMachineGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 获取算法目标部署机器可分配的端口资源
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1GetAlgorithmTargetDeployMachineGet_8(options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1GetAlgorithmTargetDeployMachineGet_8(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
   * @summary 获取可用的python镜像版本
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1GetAvaliablePythonVersionGet(options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1GetAvaliablePythonVersionGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
   * @summary 获取可用的python镜像版本
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1GetAvaliablePythonVersionGet_9(options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1GetAvaliablePythonVersionGet_9(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 通过算法唯一编码查询算法详细信息
   * @param {string} [algorithmCode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1QueryAlgorithmByCodeGet(algorithmCode?: string, options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1QueryAlgorithmByCodeGet(algorithmCode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 通过算法唯一编码查询算法详细信息
   * @param {string} [algorithmCode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1QueryAlgorithmByCodeGet_10(algorithmCode?: string, options?: AxiosRequestConfig) {
    return ScriptApiFp(this.configuration)
      .apiV1QueryAlgorithmByCodeGet_10(algorithmCode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 分页查询算法及算法实例信息
   * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1QueryAlgorithmListByConPost(
    queryAlgorithmByConInput?: QueryAlgorithmByConInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 分页查询算法及算法实例信息
   * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1QueryAlgorithmListByConPost_11(
    queryAlgorithmByConInput?: QueryAlgorithmByConInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1QueryAlgorithmListByConPost_11(queryAlgorithmByConInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
   * @summary 运行Python算法脚本实例
   * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
   * @param {{ [key: string]: string; }} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1RunAlgorithmPost(
    algorithmCode?: string,
    requestBody?: { [key: string]: string },
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1RunAlgorithmPost(algorithmCode, requestBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
   * @summary 运行Python算法脚本实例
   * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
   * @param {{ [key: string]: string; }} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1RunAlgorithmPost_12(
    algorithmCode?: string,
    requestBody?: { [key: string]: string },
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1RunAlgorithmPost_12(algorithmCode, requestBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 保存Python算法脚本
   * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1SaveAlgorithmPost(
    addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1SaveAlgorithmPost(addAlgorithmSidecarInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
   * @summary 保存Python算法脚本
   * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public apiV1SaveAlgorithmPost_13(
    addAlgorithmSidecarInput?: AddAlgorithmSidecarInput,
    options?: AxiosRequestConfig,
  ) {
    return ScriptApiFp(this.configuration)
      .apiV1SaveAlgorithmPost_13(addAlgorithmSidecarInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
