/* tslint:disable */
/* eslint-disable */
/**
 * 数据中台服务
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import { Configuration } from '../configuration'
import { URL } from '../../sdk-helper'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base'
// @ts-ignore
import { AddAlgorithmInstanceInput } from '../models';
// @ts-ignore
import { AddAlgorithmManualInput } from '../models';
// @ts-ignore
import { AddAlgorithmParamInput } from '../models';
// @ts-ignore
import { AddAlgorithmSidecarInput } from '../models';
// @ts-ignore
import { AlgorithmParamDto } from '../models';
// @ts-ignore
import { BatchDeleteAlgorithmParamInput } from '../models';
// @ts-ignore
import { DeleteAlgorithmInstanceInput } from '../models';
// @ts-ignore
import { DeleteAlgorithmParamByAIdInput } from '../models';
// @ts-ignore
import { DeleteAlgorithmSidecarInput } from '../models';
// @ts-ignore
import { DeleteInstanceListInput } from '../models';
// @ts-ignore
import { DeployMachineOutput } from '../models';
// @ts-ignore
import { QueryAlgorithmByCodeOutput } from '../models';
// @ts-ignore
import { QueryAlgorithmByCodeOutputPage } from '../models';
// @ts-ignore
import { QueryAlgorithmByConInput } from '../models';
/**
 * ScriptApi - axios parameter creator
 * @export
 */
export const ScriptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 根据算法id删除算法参数
         * @param {DeleteAlgorithmParamByAIdInput} [deleteAlgorithmParamByAIdInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeleteByAlgorithmIdPost: async (deleteAlgorithmParamByAIdInput?: DeleteAlgorithmParamByAIdInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/delete-by-algorithmId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAlgorithmParamByAIdInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 根据算法id查询算法参数
         * @param {string} [algorithmId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueryByAlgorithmIdGet: async (algorithmId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/query-by-algorithmId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (algorithmId !== undefined) {
                localVarQueryParameter['AlgorithmId'] = algorithmId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 保存Python算法脚本实例
         * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AddAlgorithmInstancePost: async (addAlgorithmInstanceInput?: AddAlgorithmInstanceInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/add/algorithm-instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAlgorithmInstanceInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 批量删除算法参数
         * @param {BatchDeleteAlgorithmParamInput} [batchDeleteAlgorithmParamInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AlgorithmParamBatchDeletePost: async (batchDeleteAlgorithmParamInput?: BatchDeleteAlgorithmParamInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/algorithm-param/batch-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchDeleteAlgorithmParamInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 删除算法关联的所有参数，重新批量新增算法参数,
         * @param {Array<AddAlgorithmParamInput>} [addAlgorithmParamInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AlgorithmParamRecreatePost: async (addAlgorithmParamInput?: Array<AddAlgorithmParamInput>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/algorithm-param/recreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAlgorithmParamInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 更新算法参数
         * @param {AlgorithmParamDto} [algorithmParamDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AlgorithmParamUpdatePost: async (algorithmParamDto?: AlgorithmParamDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/algorithm-param/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(algorithmParamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 根据Python脚本唯一编码删除Python脚本实例
         * @param {DeleteInstanceListInput} [deleteInstanceListInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DeleteAlgorithmInstanceListPost: async (deleteInstanceListInput?: DeleteInstanceListInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/delete/algorithm-instance-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteInstanceListInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 批量删除Python算法脚本实例
         * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DeleteAlgorithmInstancePost: async (deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/delete/algorithm-instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAlgorithmInstanceInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 删除Python算法脚本
         * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DeleteAlgorithmPost: async (deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/delete/algorithm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAlgorithmSidecarInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 停用算法脚本实例
         * @param {string} [algorithmInstanceCode] 算法实例唯一编码
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DisableAlgorithmGet: async (algorithmInstanceCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/disable/algorithm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (algorithmInstanceCode !== undefined) {
                localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 启用算法脚本实例
         * @param {string} [algorithmInstanceCode] 算法实例唯一编码
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1EnableAlgorithmGet: async (algorithmInstanceCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/enable/algorithm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (algorithmInstanceCode !== undefined) {
                localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 获取算法脚本实例的运行日志
         * @param {string} [algorithmInstanceCode] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GetAlgorithmLogGet: async (algorithmInstanceCode?: string, startTime?: string, endTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/get/algorithm/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (algorithmInstanceCode !== undefined) {
                localVarQueryParameter['algorithmInstanceCode'] = algorithmInstanceCode;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 获取算法目标部署机器可分配的端口资源
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GetAlgorithmTargetDeployMachineGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/get/algorithm/target/deploy/machine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
         * @summary 获取可用的python镜像版本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GetAvaliablePythonVersionGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/get-avaliable-python-version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 通过算法唯一编码查询算法详细信息
         * @param {string} [algorithmCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryAlgorithmByCodeGet: async (algorithmCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/query/algorithm/by/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (algorithmCode !== undefined) {
                localVarQueryParameter['algorithmCode'] = algorithmCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 分页查询算法及算法实例信息
         * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryAlgorithmListByConPost: async (queryAlgorithmByConInput?: QueryAlgorithmByConInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/query/algorithm/list/by/con`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryAlgorithmByConInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
         * @summary 运行Python算法脚本实例
         * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RunAlgorithmPost: async (algorithmCode?: string, requestBody?: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/run/algorithm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (algorithmCode !== undefined) {
                localVarQueryParameter['algorithmCode'] = algorithmCode;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 手动批量新增或更新算法并自动生成实例，用于数据源配置绑定算法实例id
         * @param {Array<AddAlgorithmManualInput>} [addAlgorithmManualInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SaveAlgorithmManualPost: async (addAlgorithmManualInput?: Array<AddAlgorithmManualInput>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/save/algorithm-manual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAlgorithmManualInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 保存Python算法脚本
         * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SaveAlgorithmPost: async (addAlgorithmSidecarInput?: AddAlgorithmSidecarInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/save/algorithm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAlgorithmSidecarInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScriptApi - functional programming interface
 * @export
 */
export const ScriptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScriptApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 根据算法id删除算法参数
         * @param {DeleteAlgorithmParamByAIdInput} [deleteAlgorithmParamByAIdInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDeleteByAlgorithmIdPost(deleteAlgorithmParamByAIdInput?: DeleteAlgorithmParamByAIdInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDeleteByAlgorithmIdPost(deleteAlgorithmParamByAIdInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 根据算法id查询算法参数
         * @param {string} [algorithmId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQueryByAlgorithmIdGet(algorithmId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlgorithmParamDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQueryByAlgorithmIdGet(algorithmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 保存Python算法脚本实例
         * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput?: AddAlgorithmInstanceInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 批量删除算法参数
         * @param {BatchDeleteAlgorithmParamInput} [batchDeleteAlgorithmParamInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AlgorithmParamBatchDeletePost(batchDeleteAlgorithmParamInput?: BatchDeleteAlgorithmParamInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AlgorithmParamBatchDeletePost(batchDeleteAlgorithmParamInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 删除算法关联的所有参数，重新批量新增算法参数,
         * @param {Array<AddAlgorithmParamInput>} [addAlgorithmParamInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AlgorithmParamRecreatePost(addAlgorithmParamInput?: Array<AddAlgorithmParamInput>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AlgorithmParamRecreatePost(addAlgorithmParamInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 更新算法参数
         * @param {AlgorithmParamDto} [algorithmParamDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AlgorithmParamUpdatePost(algorithmParamDto?: AlgorithmParamDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AlgorithmParamUpdatePost(algorithmParamDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 根据Python脚本唯一编码删除Python脚本实例
         * @param {DeleteInstanceListInput} [deleteInstanceListInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput?: DeleteInstanceListInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 批量删除Python算法脚本实例
         * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 删除Python算法脚本
         * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 停用算法脚本实例
         * @param {string} [algorithmInstanceCode] 算法实例唯一编码
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DisableAlgorithmGet(algorithmInstanceCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DisableAlgorithmGet(algorithmInstanceCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 启用算法脚本实例
         * @param {string} [algorithmInstanceCode] 算法实例唯一编码
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1EnableAlgorithmGet(algorithmInstanceCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1EnableAlgorithmGet(algorithmInstanceCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 获取算法脚本实例的运行日志
         * @param {string} [algorithmInstanceCode] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GetAlgorithmLogGet(algorithmInstanceCode?: string, startTime?: string, endTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1GetAlgorithmLogGet(algorithmInstanceCode, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 获取算法目标部署机器可分配的端口资源
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GetAlgorithmTargetDeployMachineGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployMachineOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1GetAlgorithmTargetDeployMachineGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
         * @summary 获取可用的python镜像版本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GetAvaliablePythonVersionGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1GetAvaliablePythonVersionGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 通过算法唯一编码查询算法详细信息
         * @param {string} [algorithmCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1QueryAlgorithmByCodeGet(algorithmCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1QueryAlgorithmByCodeGet(algorithmCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 分页查询算法及算法实例信息
         * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput?: QueryAlgorithmByConInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutputPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
         * @summary 运行Python算法脚本实例
         * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RunAlgorithmPost(algorithmCode?: string, requestBody?: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RunAlgorithmPost(algorithmCode, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 手动批量新增或更新算法并自动生成实例，用于数据源配置绑定算法实例id
         * @param {Array<AddAlgorithmManualInput>} [addAlgorithmManualInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SaveAlgorithmManualPost(addAlgorithmManualInput?: Array<AddAlgorithmManualInput>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QueryAlgorithmByCodeOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SaveAlgorithmManualPost(addAlgorithmManualInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 保存Python算法脚本
         * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SaveAlgorithmPost(addAlgorithmSidecarInput?: AddAlgorithmSidecarInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAlgorithmByCodeOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SaveAlgorithmPost(addAlgorithmSidecarInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScriptApi - factory interface
 * @export
 */
export const ScriptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScriptApiFp(configuration)
    return {
        /**
         * 
         * @summary 根据算法id删除算法参数
         * @param {DeleteAlgorithmParamByAIdInput} [deleteAlgorithmParamByAIdInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeleteByAlgorithmIdPost(deleteAlgorithmParamByAIdInput?: DeleteAlgorithmParamByAIdInput, options?: any): AxiosPromise<void> {
            return localVarFp.apiDeleteByAlgorithmIdPost(deleteAlgorithmParamByAIdInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 根据算法id查询算法参数
         * @param {string} [algorithmId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQueryByAlgorithmIdGet(algorithmId?: string, options?: any): AxiosPromise<Array<AlgorithmParamDto>> {
            return localVarFp.apiQueryByAlgorithmIdGet(algorithmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 保存Python算法脚本实例
         * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput?: AddAlgorithmInstanceInput, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 批量删除算法参数
         * @param {BatchDeleteAlgorithmParamInput} [batchDeleteAlgorithmParamInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AlgorithmParamBatchDeletePost(batchDeleteAlgorithmParamInput?: BatchDeleteAlgorithmParamInput, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AlgorithmParamBatchDeletePost(batchDeleteAlgorithmParamInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 删除算法关联的所有参数，重新批量新增算法参数,
         * @param {Array<AddAlgorithmParamInput>} [addAlgorithmParamInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AlgorithmParamRecreatePost(addAlgorithmParamInput?: Array<AddAlgorithmParamInput>, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AlgorithmParamRecreatePost(addAlgorithmParamInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 更新算法参数
         * @param {AlgorithmParamDto} [algorithmParamDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AlgorithmParamUpdatePost(algorithmParamDto?: AlgorithmParamDto, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AlgorithmParamUpdatePost(algorithmParamDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 根据Python脚本唯一编码删除Python脚本实例
         * @param {DeleteInstanceListInput} [deleteInstanceListInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput?: DeleteInstanceListInput, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 批量删除Python算法脚本实例
         * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 删除Python算法脚本
         * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 停用算法脚本实例
         * @param {string} [algorithmInstanceCode] 算法实例唯一编码
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DisableAlgorithmGet(algorithmInstanceCode?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1DisableAlgorithmGet(algorithmInstanceCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 启用算法脚本实例
         * @param {string} [algorithmInstanceCode] 算法实例唯一编码
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1EnableAlgorithmGet(algorithmInstanceCode?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1EnableAlgorithmGet(algorithmInstanceCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 获取算法脚本实例的运行日志
         * @param {string} [algorithmInstanceCode] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GetAlgorithmLogGet(algorithmInstanceCode?: string, startTime?: string, endTime?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1GetAlgorithmLogGet(algorithmInstanceCode, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 获取算法目标部署机器可分配的端口资源
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GetAlgorithmTargetDeployMachineGet(options?: any): AxiosPromise<DeployMachineOutput> {
            return localVarFp.apiV1GetAlgorithmTargetDeployMachineGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
         * @summary 获取可用的python镜像版本
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GetAvaliablePythonVersionGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiV1GetAvaliablePythonVersionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 通过算法唯一编码查询算法详细信息
         * @param {string} [algorithmCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryAlgorithmByCodeGet(algorithmCode?: string, options?: any): AxiosPromise<QueryAlgorithmByCodeOutput> {
            return localVarFp.apiV1QueryAlgorithmByCodeGet(algorithmCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 分页查询算法及算法实例信息
         * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput?: QueryAlgorithmByConInput, options?: any): AxiosPromise<QueryAlgorithmByCodeOutputPage> {
            return localVarFp.apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
         * @summary 运行Python算法脚本实例
         * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RunAlgorithmPost(algorithmCode?: string, requestBody?: { [key: string]: string; }, options?: any): AxiosPromise<object> {
            return localVarFp.apiV1RunAlgorithmPost(algorithmCode, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 手动批量新增或更新算法并自动生成实例，用于数据源配置绑定算法实例id
         * @param {Array<AddAlgorithmManualInput>} [addAlgorithmManualInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SaveAlgorithmManualPost(addAlgorithmManualInput?: Array<AddAlgorithmManualInput>, options?: any): AxiosPromise<Array<QueryAlgorithmByCodeOutput>> {
            return localVarFp.apiV1SaveAlgorithmManualPost(addAlgorithmManualInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
         * @summary 保存Python算法脚本
         * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SaveAlgorithmPost(addAlgorithmSidecarInput?: AddAlgorithmSidecarInput, options?: any): AxiosPromise<QueryAlgorithmByCodeOutput> {
            return localVarFp.apiV1SaveAlgorithmPost(addAlgorithmSidecarInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScriptApi - object-oriented interface
 * @export
 * @class ScriptApi
 * @extends {BaseAPI}
 */
export class ScriptApi extends BaseAPI {
    /**
     * 
     * @summary 根据算法id删除算法参数
     * @param {DeleteAlgorithmParamByAIdInput} [deleteAlgorithmParamByAIdInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiDeleteByAlgorithmIdPost(deleteAlgorithmParamByAIdInput?: DeleteAlgorithmParamByAIdInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiDeleteByAlgorithmIdPost(deleteAlgorithmParamByAIdInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 根据算法id查询算法参数
     * @param {string} [algorithmId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiQueryByAlgorithmIdGet(algorithmId?: string, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiQueryByAlgorithmIdGet(algorithmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本实例、保存  使用场景：      导入脚本完成后，系统会自动生成一个默认的脚本实例，但如果需要更新或创建新的实例，则可以调用该接口新增或更新。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本实例
     * @param {AddAlgorithmInstanceInput} [addAlgorithmInstanceInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput?: AddAlgorithmInstanceInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1AddAlgorithmInstancePost(addAlgorithmInstanceInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 批量删除算法参数
     * @param {BatchDeleteAlgorithmParamInput} [batchDeleteAlgorithmParamInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1AlgorithmParamBatchDeletePost(batchDeleteAlgorithmParamInput?: BatchDeleteAlgorithmParamInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1AlgorithmParamBatchDeletePost(batchDeleteAlgorithmParamInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 删除算法关联的所有参数，重新批量新增算法参数,
     * @param {Array<AddAlgorithmParamInput>} [addAlgorithmParamInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1AlgorithmParamRecreatePost(addAlgorithmParamInput?: Array<AddAlgorithmParamInput>, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1AlgorithmParamRecreatePost(addAlgorithmParamInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 更新算法参数
     * @param {AlgorithmParamDto} [algorithmParamDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1AlgorithmParamUpdatePost(algorithmParamDto?: AlgorithmParamDto, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1AlgorithmParamUpdatePost(algorithmParamDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      在更新完一个算法脚本后（通常是需要在不改变唯一编码的情况下，重新导入压缩包），需要删除该算法脚本已经生成的所有实例（容器）  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 根据Python脚本唯一编码删除Python脚本实例
     * @param {DeleteInstanceListInput} [deleteInstanceListInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput?: DeleteInstanceListInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1DeleteAlgorithmInstanceListPost(deleteInstanceListInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本实例、删除  使用场景：      批量删除算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 批量删除Python算法脚本实例
     * @param {DeleteAlgorithmInstanceInput} [deleteAlgorithmInstanceInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput?: DeleteAlgorithmInstanceInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1DeleteAlgorithmInstancePost(deleteAlgorithmInstanceInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、删除  使用场景：      删除一个算法脚本及其所有的实例，其背后实质是删除算法脚本的所有容器和镜像  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 删除Python算法脚本
     * @param {DeleteAlgorithmSidecarInput} [deleteAlgorithmSidecarInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput?: DeleteAlgorithmSidecarInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1DeleteAlgorithmPost(deleteAlgorithmSidecarInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、停用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 停用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1DisableAlgorithmGet(algorithmInstanceCode?: string, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1DisableAlgorithmGet(algorithmInstanceCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、启用  使用场景：      停用算法脚本实例  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 启用算法脚本实例
     * @param {string} [algorithmInstanceCode] 算法实例唯一编码
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1EnableAlgorithmGet(algorithmInstanceCode?: string, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1EnableAlgorithmGet(algorithmInstanceCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、日志  使用场景：      根据算法唯一编码和时间范围，查询算法运行日志  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法脚本实例的运行日志
     * @param {string} [algorithmInstanceCode] 
     * @param {string} [startTime] 
     * @param {string} [endTime] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1GetAlgorithmLogGet(algorithmInstanceCode?: string, startTime?: string, endTime?: string, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1GetAlgorithmLogGet(algorithmInstanceCode, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、端口资源  使用场景：      在导入算法脚本生成算法实例时由系统调用该接口获取可用端口资源，通常不由用户直接调用  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 获取算法目标部署机器可分配的端口资源
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1GetAlgorithmTargetDeployMachineGet(options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1GetAlgorithmTargetDeployMachineGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、版本  使用场景：      提供服务器上可用的python镜像版本，供导入脚本创建镜像时使用，系统将基于该版本镜像构建脚本镜像  相关背景：     若不指定python版本，系统默认使用python:3.10-slim-buster版本构建镜像
     * @summary 获取可用的python镜像版本
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1GetAvaliablePythonVersionGet(options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1GetAvaliablePythonVersionGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 通过算法唯一编码查询算法详细信息
     * @param {string} [algorithmCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1QueryAlgorithmByCodeGet(algorithmCode?: string, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1QueryAlgorithmByCodeGet(algorithmCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、查询  使用场景：      已知算法唯一编码，查询该算法的详细信息，包括关联的算法实例信息  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 分页查询算法及算法实例信息
     * @param {QueryAlgorithmByConInput} [queryAlgorithmByConInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput?: QueryAlgorithmByConInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1QueryAlgorithmListByConPost(queryAlgorithmByConInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、运行  使用场景：      在已知算法实例唯一编码的情况下，对其进行调用，调用方式可以是任务调度定时执行，也可以是前端或其他服务的单次执行  相关背景：      需要完成python脚本压缩包导入并生成一个脚本实例后，方可调用执行，可通过\"DHI项目配置平台\"完成导入操作。  输出：      算法脚本实例执行结果，该结果的字符串值由用户的算法脚本的执行结果决定
     * @summary 运行Python算法脚本实例
     * @param {string} [algorithmCode] 算法实例唯一编码，可通过接口&#x60;&#x60;&#x60;v1/query/algorithm/list/by/con&#x60;&#x60;&#x60;获得算法和算法实例信息
     * @param {{ [key: string]: string; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1RunAlgorithmPost(algorithmCode?: string, requestBody?: { [key: string]: string; }, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1RunAlgorithmPost(algorithmCode, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 手动批量新增或更新算法并自动生成实例，用于数据源配置绑定算法实例id
     * @param {Array<AddAlgorithmManualInput>} [addAlgorithmManualInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1SaveAlgorithmManualPost(addAlgorithmManualInput?: Array<AddAlgorithmManualInput>, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1SaveAlgorithmManualPost(addAlgorithmManualInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 关键词：      插件、脚本、保存  使用场景：      新增或更新一个算法脚本，该接口在脚本导入过程中由后台服务调用完成，通常不由用户单独调用。  相关背景：      一个算法脚本可以对应一个或多个算法脚本实例，其背后是docker镜像和docker容器的对应关系
     * @summary 保存Python算法脚本
     * @param {AddAlgorithmSidecarInput} [addAlgorithmSidecarInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public apiV1SaveAlgorithmPost(addAlgorithmSidecarInput?: AddAlgorithmSidecarInput, options?: AxiosRequestConfig) {
        return ScriptApiFp(this.configuration).apiV1SaveAlgorithmPost(addAlgorithmSidecarInput, options).then((request) => request(this.axios, this.basePath));
    }
}
